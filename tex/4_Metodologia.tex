
\par Este capítulo ...

% Ruídos gerados
% Ver slides das aulas 7,8 e 9 de IPI, e ver https://en.wikipedia.org/wiki/Image_noise

\section{Arquitetura proposta} \label{sec:metodologia:arquitetura}

\par Este projeto consiste na proposta uma arquitetura de sistema de reconhecimento de íris que usa duas métricas de qualidade, \textit{\acrfull{DSMI}} para medir a qualidade da imagem de íris de entrada e \textit{\acrfull{FCE}} para medir a qualidade da íris segmentada, e analisar como essas métricas podem influenciar no desempenho do sistema. A \refFig{fig:metodologia:arquitetura} ilustra o diagrama da arquitetura proposta.

\figura[h!]{img/Metodologia/arquitetura_proposta}{Diagrama da arquitetura do sistema de reconhecimento de íris com as métricas de qualidade\textit{\acrshort{DSMI}} e \textit{\acrshort{FCE}} proposta. $T_{DSMI}$ é o limiar definido para a métrica \textit{DSMI}, $T_{FCE}$ o limiar da métrica \textit{FCE} e \textit{T} o limiar para aceitar ou rejeitar um indivíduo que está sendo autenticado a partir da \textit{\acrfull{HD}} calculada entre seus modelos}{fig:metodologia:arquitetura}{width=0.8\textwidth}

\par Conforme explicitado na \refFig{fig:metodologia:arquitetura}, o funcionamento do sistema proposto consiste em: proporcionar uma imagem de íris \textit{\acrfull{VL}} de entrada; calcular a sua qualidade $Q_{DSMI}$ por meio da métrica \textit{\acrshort{DSMI}} e verificar por meio do limiar $T_{DSMI}$ se a qualidade é boa o bastante, se sim, permitir que a imagem para o módulo de segmentação, se não solicitar por outra imagem de íris; segmentar e normalizar a imagem da íris por algum algoritmo de segmentação e normalização; calcular a qualidade da segmentação $Q_{FCE}$ e verificar se é ou não boa o bastante para a codificação a partir do limiar $T_{FCE}$, se sim, permitir que a íris seja codificada e se não, solicitar por outra imagem de íris e repetir as etapas; extrair os atributos da íris segmentada e gerar seu código ou modelo (\textit{IrisCode}) por algum algoritmo de codificação; comparar o modelo calculado com modelos armazenados no módulo de correspondência, que podem ou não ser do mesmo indivíduo, dependendo do tipo de sistema de reconhecimento de íris, e calcular a \textit{\acrfull{HD}} dos modelos; e por fim, comparar a \textit{\acrshort{HD}} calculada com o limiar \textit{T} definido para o sistema e verificar se houve correspondência e aceitar ou rejeitar a autenticação.

\par A arquitetura do sistema proposto foi projetada para ser flexível, de forma que qualquer sistema de reconhecimento de íris pudesse ser usado. Essa flexibilidade possibilita o uso de diversos algoritmos de segmentação, codificação e correspondência de íris, contanto que suas saídas sejam compatíveis com as métricas \textit{\acrshort{DSMI}} e \textit{\acrshort{FCE}}, e que o resultado da correspondência seja uma distância.

\par Como o objetivo do projeto é a análise das métricas na taxa de desempenho de sistemas de reconhecimento de íris, o sistema de reconhecimento de íris \textit{OSIRISv4.1} \cite{othman2015, osirisv41} foi utilizado na arquitetura proposta, e a etapa de registro foi desconsiderada no diagrama da \refFig{fig:metodologia:arquitetura}, já que somente a análise da etapa de autenticação é necessária e bancos de dados de íris prontos foram usados nos experimentos.

\par Por ser um sistema de código aberto (\textit{open source}), ter bons desempenhos em bases de dados de íris conhecidas e ser o sistema usado por \cite{Jenadeleh_2018_CVPR_Workshops} para seus experimentos, o sistema de reconhecimento de íris \textit{OSIRISv4.1} foi escolhido para o sistema da arquitetura proposta.

\par Os limiares $T_{DSMI}$, $T_{FCE}$ e $T$ foram definidos de acordo com os critérios explicados no Capítulo 5.

\par Cada um dos blocos ou módulos apresentados na \refFig{fig:metodologia:arquitetura} serão explicados como funcionam e como foram implementados com mais detalhes nas Seções \ref{sec:metodologia:dsmi} até \ref{sec:metodologia:correspondencia}.

\subsection{DSMI}\label{sec:metodologia:dsmi}

\par O módulo \acrshort{DSMI} consiste no módulo responsável pelo cálculo da qualidade da imagem de íris de entrada no sistema proposto, pela métrica \textit{\acrshort{DSMI}}. O módulo deve receber como entrada uma imagem de íris \textit{\acrshort{VL}}, calcular sua qualidade e decidir se a imagem é ou não boa suficiente para continuar para o próximo módulo. A \refFig{fig:metodologia:dsmi} ilustra o módulo e os passos descritos acima.

\figura[h!]{img/Metodologia/dsmi}{Representação do módulo da métrica de qualidade \textit{DSMI} no diagrama da arquitetura proposta. A sua entrada é uma imagem de íris \textit{\acrshort{VL}} e saída é a qualidade da imagem $Q_{DSMI}$, sendo um valor entre 0 e 1. Enfim, o módulo deve decidir se a imagem é ou não boa o suficiente com base no limiar $T_{DSMI}$}{fig:metodologia:dsmi}{width=0.5\textwidth}

\par A métrica consiste no cálculo de componentes de sinal e magnitude da imagem, $S_{1}$ e $S_{2}$, na combinação desses componentes na estatística de coincidência de padrões $S$ e no cálculo da variância das vizinhanças da imagem, para enfim, calcular a qualidade final $Q_{DSMI}$.

\par O componente de sinal $S_{1}$ consiste no cálculo dos máximos locais da imagem de entrada (\refEq{eq:dsmi:s1}) e o componente de magnitude $S_{2}$ na comparação de um limiar global \textit{T} com as máximas diferenças locais (\refEq{eq:dsmi:s2}). Os passos para calcular os máximos locais e as máximas diferenças seguem os seguintes passos:

\begin{enumerate}
    \item Obter imagem resultante $Maximas$ do processamento da imagem de entrada com a operação morfológica de dilatação (Seção \ref{sec:morf:dil}), considerando a vizinhança vertical e horizontal (Elemento estruturante da \refFig{fig:kernel_morfo});
    \item Obter imagem resultante $Minimas$ do processamento da imagem de entrada com a operação morfológica de erosão (Seção \ref{sec:morf:ero}), considerando a vizinhança vertical e horizontal (Elemento estruturante da \refFig{fig:kernel_morfo});
    \item Calcular as absolutas diferenças entre $Maximas$ e a imagem de entrada, conforme: $X = |I_{entrada} - Maximas|$;
    \item Calcular as absolutas diferenças entre a imagem de entrada e $Minimas$, conforme: $Y = |Minimas - I_{entrada}|$;
    \item Comparar os \textit{píxels} da imagem de entrada com o equivalente da imagem $Maximas$, e verificar se é maior, se for, é um máximo local e 1 é atribuído à posição em $S_{1}$ (\refEq{eq:dsmi:s1});
    \item Calcular $max(X, Y)$ de forma a obter as máximas diferenças $MaxDiffs$ da imagem de entrada.
\end{enumerate}

\par Com os máximos locais encontrados, o limiar $T$ usado para calcular os componentes de magnitude $S_{2}$ é calculado conforme a \refEq{eq:dsmi:T}, para então calcular $S_{2}$. 

\par A estatística da coincidência dos padrões $S$ é calculada de acordo com a \refEq{eq:dsmi:s}. A variância das vizinhanças dos \textit{pixels} da imagem de entrada $\sigma^2$ (\refEq{eq:dsmi:var}) é calculada por meio do filtro de \textit{Variância Local} (Seção \ref{sec:dom_esp:filtro_std}) com a máscara (\textit{kernel}) representada pela \refFig{fig:kernel_morfo}.

\par Com $S$ e $\sigma^2$, a qualidade final $Q_{DSMI}$ é, por fim, calculada conforme a \refEq{eq:dsmi:Q} e normalizada pela \refEq{eq:dsmi:r}.

\par O módulo decide então se a imagem é ou não boa o suficiente para ser segmentada comparando o limiar $T_{DSMI}$ com a qualidade $Q_{DSMI}$.

% \begin{algorithm} % enter the algorithm environment
% \caption{Calculate $y = x^n$} % give the algorithm a caption
% \label{alg1} % and a label for \ref{} commands later in the document
% \begin{algorithmic} % enter the algorithmic environment
%     \REQUIRE $n \geq 0 \vee x \neq 0$
%     \ENSURE $y = x^n$
%     \STATE $y \Leftarrow 1$
%     \IF{$n < 0$}
%         \STATE $X \Leftarrow 1 / x$
%         \STATE $N \Leftarrow -n$
%     \ELSE
%         \STATE $X \Leftarrow x$
%         \STATE $N \Leftarrow n$
%     \ENDIF
%     \WHILE{$N \neq 0$}
%         \IF{$N$ is even}
%             \STATE $X \Leftarrow X \times X$
%             \STATE $N \Leftarrow N / 2$
%         \ELSE[$N$ is odd]
%             \STATE $y \Leftarrow y \times X$
%             \STATE $N \Leftarrow N - 1$
%         \ENDIF
%     \ENDWHILE
% \end{algorithmic}
% \end{algorithm}

\subsection{Segmentação}\label{sec:metodologia:segmentacao}

\par O módulo de segmentação é o módulo responsável por segmentar e normalizar a imagem de íris de entrada no sistema. O módulo deve receber a imagem de íris que passou pelo módulo \acrshort{DSMI}, segmentá-la e normalizá-la, resultando nos parâmetros: raio e posição central da íris e da pupila, onde (X, Y, R) são as coordenadas da posição e o raio, respectivamente; máscara binária da íris segmentada; íris normalizada em coordenadas polares; e a máscara binária da imagem normalizada. Nas máscaras binárias, os \textit{pixels} pretos são ruídos como pálpebras e cílios, e os \textit{pixels} brancos são íris corretamente segmentadas. A \refFig{fig:metodologia:segmentacao} ilustra o módulo e as entradas e saídas do módulo.

\figura[h!]{img/Metodologia/modulo_segmentacao}{Módulo que segmenta e normaliza a imagem de íris. As etapas de segmentação e normalização são divididas em dois blocos separados, de forma que qualquer algoritmo de segmentação ou normalização pudesse ser usado. Sua entrada consiste na imagem de íris \textit{\acrshort{VL}} e suas saídas são as posições centrais e raio da íris e pupila, máscaras binárias da íris e da íris normalizada, e a íris normalizada}{fig:metodologia:segmentacao}{width=0.8\textwidth}

\par O sistema de reconhecimento de íris escolhido para os experimentos foi o \textit{OSIRISv4.1} \cite{othman2015}.

\par A etapa de segmentação do \textit{OSIRISv4.1} consiste em dois passos: encontrar a posição central da pupila e seu raio para então encontrar a íris \cite{osirisv41_doc}. A pupila é encontrada seguindo dois critérios: (i) calcular o valor mínimo na imagem sendo filtrada por uma máscara de raio $r$, aonde o processo de filtragem é a soma da vizinhança considerada pela máscara; (ii) calcular os gradientes verticais e horizontais da imagem usando o operador \textit{Sobel} \cite{kanopoulos1988}, construir duas máscaras de raio $r$, filtrar os gradientes com as duas máscaras construídas e encontrar o valor máximo da soma do resultado das duas filtragens. Os critérios (i) e (ii)  são repetidos para vários valores de raio da pupila $r$, e o valor máximo do resultado das somas dos dois critérios representa o melhor candidato para a pupila. Os contornos da íris devem ser encontrados, então o algoritmo \textit{Viterbi} \cite{sutra2012} é usado. O algoritmo é aplicado em duas resoluções: altas e baixas. A resolução alta é usada para encontrar os contornos precisos da íris e a resolução baixa para os contornos grosseiros (\textit{coarse contours}). O centro da íris e seu raio são calculados pelos procedimentos descritos acima. 

\par A etapa de normalização do \textit{OSIRISv4.1} é feita usando os contornos grosseiros encontrados na etapa de segmentação em conjunto com o \textit{Modelo Rubber Sheet} (Seção \ref{sec:iris:rec_iris}).

\par As \refFigs{fig:metodologia:original}{fig:metodologia:mascara_binaria_norm} ilustram os resultados das etapas de segmentação e normalização.

\figura[h!]{img/Metodologia/Img_24_1_4}{Imagem de íris \textit{\acrshort{VL}} original}{fig:metodologia:original}{width=.3\textwidth}

\figura[h!]{img/Metodologia/}{}{fig:metodologia:original}{width=.3\textwidth}

\figurasDuplas{h!}{img/Metodologia/Img_24_1_4_segm}{img/Metodologia/Img_24_1_4_mask}{Processo de normalização de uma imagem de íris segmentada}{Imagem original antes da normalização}{Imagem de íris normalizada}{fig:normalizacao}{fig:antes_normalizada}{{fig:normalizada}{.5\textwidth}{width=.8\linewidth}}

\figurasDuplas{h!}{img/Metodologia/Img_24_1_4_imno}{img/Metodologia/Img_24_1_4_mano}{Processo de normalização de uma imagem de íris segmentada}{Imagem original antes da normalização}{Imagem de íris normalizada}{fig:normalizacao}{fig:antes_normalizada}{{fig:normalizada}{.5\textwidth}{width=.8\linewidth}}


\subsection{FCE}\label{sec:metodologia:fce}

\figura[h!]{img/Metodologia/fce}{}{fig:metodologia:fce}{width=0.6\textwidth}

\subsection{Codificação}\label{sec:metodologia:codificacao}

\figura[h!]{img/Metodologia/modulo_codificacao}{}{fig:metodologia:codificacao}{width=0.8\textwidth}

\subsection{Correspondência}\label{sec:metodologia:correspondencia}

\figura[h!]{img/Metodologia/modulo_correspondencia}{}{fig:metodologia:correspondencia}{width=0.8\textwidth}